// This file is generated by omniidl (C++ backend)- omniORB_4_2. Do not edit.
#ifndef __CFCommonTypes_hh__
#define __CFCommonTypes_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_CFCommonTypes
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_CFCommonTypes
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_CFCommonTypes
#endif



#ifndef __CFPrimitiveTypes_hh_EXTERNAL_GUARD__
#define __CFPrimitiveTypes_hh_EXTERNAL_GUARD__
#include <CFPrimitiveTypes.h>
#endif
#ifndef __CFULongLongSeq_hh_EXTERNAL_GUARD__
#define __CFULongLongSeq_hh_EXTERNAL_GUARD__
#include <CFULongLongSeq.h>
#endif
#ifndef __CFBooleanSeq_hh_EXTERNAL_GUARD__
#define __CFBooleanSeq_hh_EXTERNAL_GUARD__
#include <CFBooleanSeq.h>
#endif
#ifndef __CFULongSeq_hh_EXTERNAL_GUARD__
#define __CFULongSeq_hh_EXTERNAL_GUARD__
#include <CFULongSeq.h>
#endif
#ifndef __CFLongLongSeq_hh_EXTERNAL_GUARD__
#define __CFLongLongSeq_hh_EXTERNAL_GUARD__
#include <CFLongLongSeq.h>
#endif
#ifndef __CFCharSeq_hh_EXTERNAL_GUARD__
#define __CFCharSeq_hh_EXTERNAL_GUARD__
#include <CFCharSeq.h>
#endif
#ifndef __CFUShortSeq_hh_EXTERNAL_GUARD__
#define __CFUShortSeq_hh_EXTERNAL_GUARD__
#include <CFUShortSeq.h>
#endif
#ifndef __CFLongSeq_hh_EXTERNAL_GUARD__
#define __CFLongSeq_hh_EXTERNAL_GUARD__
#include <CFLongSeq.h>
#endif
#ifndef __CFDoubleSeq_hh_EXTERNAL_GUARD__
#define __CFDoubleSeq_hh_EXTERNAL_GUARD__
#include <CFDoubleSeq.h>
#endif
#ifndef __CFShortSeq_hh_EXTERNAL_GUARD__
#define __CFShortSeq_hh_EXTERNAL_GUARD__
#include <CFShortSeq.h>
#endif
#ifndef __CFFloatSeq_hh_EXTERNAL_GUARD__
#define __CFFloatSeq_hh_EXTERNAL_GUARD__
#include <CFFloatSeq.h>
#endif
#ifndef __CFOctetSeq_hh_EXTERNAL_GUARD__
#define __CFOctetSeq_hh_EXTERNAL_GUARD__
#include <CFOctetSeq.h>
#endif
#ifndef __CFStringSeq_hh_EXTERNAL_GUARD__
#define __CFStringSeq_hh_EXTERNAL_GUARD__
#include <CFStringSeq.h>
#endif
#ifndef __CFProperties_hh_EXTERNAL_GUARD__
#define __CFProperties_hh_EXTERNAL_GUARD__
#include <CFProperties.h>
#endif



#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif



_CORBA_MODULE CF

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_OctetSequence;

  typedef OctetSeq OctetSequence;
  typedef OctetSeq_var OctetSequence_var;
  typedef OctetSeq_out OctetSequence_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_StringSequence;

  class StringSequence_var;

  class StringSequence : public _CORBA_Unbounded_Sequence_String {
  public:
    typedef StringSequence_var _var_type;
    inline StringSequence() {}
    inline StringSequence(const StringSequence& _s)
      : _CORBA_Unbounded_Sequence_String(_s) {}

    inline StringSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_String(_max) {}
    inline StringSequence(_CORBA_ULong _max, _CORBA_ULong _len, char** _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_String(_max, _len, _val, _rel) {}

  

    inline StringSequence& operator = (const StringSequence& _s) {
      _CORBA_Unbounded_Sequence_String::operator=(_s);
      return *this;
    }
  };

  class StringSequence_out;

  class StringSequence_var {
  public:
    inline StringSequence_var() : _pd_seq(0) {}
    inline StringSequence_var(StringSequence* _s) : _pd_seq(_s) {}
    inline StringSequence_var(const StringSequence_var& _s) {
      if (_s._pd_seq)  _pd_seq = new StringSequence(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~StringSequence_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline StringSequence_var& operator = (StringSequence* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline StringSequence_var& operator = (const StringSequence_var& _s) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new StringSequence;
        *_pd_seq = *_s._pd_seq;
      } else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline _CORBA_String_element operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline StringSequence* operator -> () { return _pd_seq; }
    inline const StringSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator StringSequence& () const { return *_pd_seq; }
#else
    inline operator const StringSequence& () const { return *_pd_seq; }
    inline operator StringSequence& () { return *_pd_seq; }
#endif
      
    inline const StringSequence& in() const { return *_pd_seq; }
    inline StringSequence&       inout()    { return *_pd_seq; }
    inline StringSequence*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline StringSequence* _retn() { StringSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class StringSequence_out;
    
  private:
    StringSequence* _pd_seq;
  };

  class StringSequence_out {
  public:
    inline StringSequence_out(StringSequence*& _s) : _data(_s) { _data = 0; }
    inline StringSequence_out(StringSequence_var& _s)
      : _data(_s._pd_seq) { _s = (StringSequence*) 0; }
    inline StringSequence_out(const StringSequence_out& _s) : _data(_s._data) {}
    inline StringSequence_out& operator = (const StringSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline StringSequence_out& operator = (StringSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator StringSequence*&()  { return _data; }
    inline StringSequence*& ptr()       { return _data; }
    inline StringSequence* operator->() { return _data; }

    inline _CORBA_String_element operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    StringSequence*& _data;

  private:
    StringSequence_out();
    StringSequence_out& operator=(const StringSequence_var&);
  };

  enum ErrorNumberType { CF_NOTSET, CF_E2BIG, CF_EACCES, CF_EAGAIN, CF_EBADF, CF_EBADMSG, CF_EBUSY, CF_ECANCELED, CF_ECHILD, CF_EDEADLK, CF_EDOM, CF_EEXIST, CF_EFAULT, CF_EFBIG, CF_EINPROGRESS, CF_EINTR, CF_EINVAL, CF_EIO, CF_EISDIR, CF_EMFILE, CF_EMLINK, CF_EMSGSIZE, CF_ENAMETOOLONG, CF_ENFILE, CF_ENODEV, CF_ENOENT, CF_ENOEXEC, CF_ENOLCK, CF_ENOMEM, CF_ENOSPC, CF_ENOSYS, CF_ENOTDIR, CF_ENOTEMPTY, CF_ENOTSUP, CF_ENOTTY, CF_ENXIO, CF_EPERM, CF_EPIPE, CF_ERANGE, CF_EROFS, CF_ESPIPE, CF_ESRCH, CF_ETIMEDOUT, CF_EXDEV /*, __max_ErrorNumberType=0xffffffff */ };
  typedef ErrorNumberType& ErrorNumberType_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ErrorNumberType;

  class InvalidFileName : public ::CORBA::UserException {
  public:
    
    ErrorNumberType errorNumber;

    ::CORBA::String_member msg;

  

    inline InvalidFileName() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    InvalidFileName(const InvalidFileName&);
    InvalidFileName(ErrorNumberType i_errorNumber, const char* i_msg);
    InvalidFileName& operator=(const InvalidFileName&);
    virtual ~InvalidFileName();
    virtual void _raise() const;
    static InvalidFileName* _downcast(::CORBA::Exception*);
    static const InvalidFileName* _downcast(const ::CORBA::Exception*);
    static inline InvalidFileName* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    void operator>>=(cdrStream&) const ;
    void operator<<=(cdrStream&) ;

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_InvalidFileName;

  class InvalidObjectReference : public ::CORBA::UserException {
  public:
    
    ::CORBA::String_member msg;

  

    inline InvalidObjectReference() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    InvalidObjectReference(const InvalidObjectReference&);
    InvalidObjectReference(const char* i_msg);
    InvalidObjectReference& operator=(const InvalidObjectReference&);
    virtual ~InvalidObjectReference();
    virtual void _raise() const;
    static InvalidObjectReference* _downcast(::CORBA::Exception*);
    static const InvalidObjectReference* _downcast(const ::CORBA::Exception*);
    static inline InvalidObjectReference* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    void operator>>=(cdrStream&) const ;
    void operator<<=(cdrStream&) ;

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_InvalidObjectReference;

  struct PortAccessType {
    typedef _CORBA_ConstrType_Variable_Var<PortAccessType> _var_type;

    
    ::CORBA::String_member portName;

    ::CORBA::Object_Member portReference;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef PortAccessType::_var_type PortAccessType_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< PortAccessType,PortAccessType_var > PortAccessType_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PortAccessType;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Ports;

  class Ports_var;

  class Ports : public _CORBA_Unbounded_Sequence< PortAccessType >  {
  public:
    typedef Ports_var _var_type;
    inline Ports() {}
    inline Ports(const Ports& _s)
      : _CORBA_Unbounded_Sequence< PortAccessType > (_s) {}

    inline Ports(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< PortAccessType > (_max) {}
    inline Ports(_CORBA_ULong _max, _CORBA_ULong _len, PortAccessType* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< PortAccessType > (_max, _len, _val, _rel) {}

  

    inline Ports& operator = (const Ports& _s) {
      _CORBA_Unbounded_Sequence< PortAccessType > ::operator=(_s);
      return *this;
    }
  };

  class Ports_out;

  class Ports_var {
  public:
    inline Ports_var() : _pd_seq(0) {}
    inline Ports_var(Ports* _s) : _pd_seq(_s) {}
    inline Ports_var(const Ports_var& _s) {
      if (_s._pd_seq)  _pd_seq = new Ports(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~Ports_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline Ports_var& operator = (Ports* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline Ports_var& operator = (const Ports_var& _s) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new Ports;
        *_pd_seq = *_s._pd_seq;
      } else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline PortAccessType& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline Ports* operator -> () { return _pd_seq; }
    inline const Ports* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator Ports& () const { return *_pd_seq; }
#else
    inline operator const Ports& () const { return *_pd_seq; }
    inline operator Ports& () { return *_pd_seq; }
#endif
      
    inline const Ports& in() const { return *_pd_seq; }
    inline Ports&       inout()    { return *_pd_seq; }
    inline Ports*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline Ports* _retn() { Ports* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class Ports_out;
    
  private:
    Ports* _pd_seq;
  };

  class Ports_out {
  public:
    inline Ports_out(Ports*& _s) : _data(_s) { _data = 0; }
    inline Ports_out(Ports_var& _s)
      : _data(_s._pd_seq) { _s = (Ports*) 0; }
    inline Ports_out(const Ports_out& _s) : _data(_s._data) {}
    inline Ports_out& operator = (const Ports_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline Ports_out& operator = (Ports* _s) {
      _data = _s;
      return *this;
    }
    inline operator Ports*&()  { return _data; }
    inline Ports*& ptr()       { return _data; }
    inline Ports* operator->() { return _data; }

    inline PortAccessType& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    Ports*& _data;

  private:
    Ports_out();
    Ports_out& operator=(const Ports_var&);
  };

  enum ComponentEnumType { APPLICATION_COMPONENT, MANAGEABLE_APPLICATION_COMPONENT, DEVICE_COMPONENT, LOADABLE_DEVICE_COMPONENT, EXECUTABLE_DEVICE_COMPONENT, MANAGEABLE_SERVICE_COMPONENT, SERVICE_COMPONENT, DEVICE_MANAGER_COMPONENT, DOMAIN_MANAGER_COMPONENT, APPLICATION_MANAGER_COMPONENT, APPLICATION_FACTORY_COMPONENT, APPLICATION_COMPONENT_FACTORY_COMPONENT, PLATFORM_COMPONENT_FACTORY_COMPONENT /*, __max_ComponentEnumType=0xffffffff */ };
  typedef ComponentEnumType& ComponentEnumType_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ComponentEnumType;

  struct ComponentType {
    typedef _CORBA_ConstrType_Variable_Var<ComponentType> _var_type;

    
    ::CORBA::String_member identifier;

    ::CORBA::String_member profile;

    ComponentEnumType type;

    ::CORBA::Object_Member componentObject;

    Ports providesPorts;

    Properties specializedInfo;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef ComponentType::_var_type ComponentType_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< ComponentType,ComponentType_var > ComponentType_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ComponentType;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ObjectSequence;

  class ObjectSequence_var;

  class ObjectSequence : public _CORBA_Unbounded_Sequence_ObjRef< ::CORBA::Object, ::CORBA::Object_Element, ::CORBA::Object_Helper >  {
  public:
    typedef ObjectSequence_var _var_type;
    inline ObjectSequence() {}
    inline ObjectSequence(const ObjectSequence& _s)
      : _CORBA_Unbounded_Sequence_ObjRef< ::CORBA::Object, ::CORBA::Object_Element, ::CORBA::Object_Helper > (_s) {}

    inline ObjectSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_ObjRef< ::CORBA::Object, ::CORBA::Object_Element, ::CORBA::Object_Helper > (_max) {}
    inline ObjectSequence(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Object_ptr* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_ObjRef< ::CORBA::Object, ::CORBA::Object_Element, ::CORBA::Object_Helper > (_max, _len, _val, _rel) {}

  

    inline ObjectSequence& operator = (const ObjectSequence& _s) {
      _CORBA_Unbounded_Sequence_ObjRef< ::CORBA::Object, ::CORBA::Object_Element, ::CORBA::Object_Helper > ::operator=(_s);
      return *this;
    }
  };

  class ObjectSequence_out;

  class ObjectSequence_var {
  public:
    inline ObjectSequence_var() : _pd_seq(0) {}
    inline ObjectSequence_var(ObjectSequence* _s) : _pd_seq(_s) {}
    inline ObjectSequence_var(const ObjectSequence_var& _s) {
      if (_s._pd_seq)  _pd_seq = new ObjectSequence(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~ObjectSequence_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline ObjectSequence_var& operator = (ObjectSequence* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline ObjectSequence_var& operator = (const ObjectSequence_var& _s) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new ObjectSequence;
        *_pd_seq = *_s._pd_seq;
      } else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::Object_Element operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline ObjectSequence* operator -> () { return _pd_seq; }
    inline const ObjectSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator ObjectSequence& () const { return *_pd_seq; }
#else
    inline operator const ObjectSequence& () const { return *_pd_seq; }
    inline operator ObjectSequence& () { return *_pd_seq; }
#endif
      
    inline const ObjectSequence& in() const { return *_pd_seq; }
    inline ObjectSequence&       inout()    { return *_pd_seq; }
    inline ObjectSequence*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline ObjectSequence* _retn() { ObjectSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class ObjectSequence_out;
    
  private:
    ObjectSequence* _pd_seq;
  };

  class ObjectSequence_out {
  public:
    inline ObjectSequence_out(ObjectSequence*& _s) : _data(_s) { _data = 0; }
    inline ObjectSequence_out(ObjectSequence_var& _s)
      : _data(_s._pd_seq) { _s = (ObjectSequence*) 0; }
    inline ObjectSequence_out(const ObjectSequence_out& _s) : _data(_s._data) {}
    inline ObjectSequence_out& operator = (const ObjectSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline ObjectSequence_out& operator = (ObjectSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator ObjectSequence*&()  { return _data; }
    inline ObjectSequence*& ptr()       { return _data; }
    inline ObjectSequence* operator->() { return _data; }

    inline ::CORBA::Object_Element operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    ObjectSequence*& _data;

  private:
    ObjectSequence_out();
    ObjectSequence_out& operator=(const ObjectSequence_var&);
  };

_CORBA_MODULE_END



_CORBA_MODULE POA_CF
_CORBA_MODULE_BEG

_CORBA_MODULE_END



_CORBA_MODULE OBV_CF
_CORBA_MODULE_BEG

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr

void operator<<=(::CORBA::Any& _a, const CF::StringSequence& _s);
void operator<<=(::CORBA::Any& _a, CF::StringSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::StringSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::StringSequence*& _sp);

inline void operator >>=(CF::ErrorNumberType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (CF::ErrorNumberType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= CF::CF_EXDEV) {
    _e = (CF::ErrorNumberType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, CF::ErrorNumberType _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::ErrorNumberType& _s);

void operator<<=(::CORBA::Any& _a, const CF::InvalidFileName& _s);
void operator<<=(::CORBA::Any& _a, const CF::InvalidFileName* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::InvalidFileName*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::InvalidObjectReference& _s);
void operator<<=(::CORBA::Any& _a, const CF::InvalidObjectReference* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::InvalidObjectReference*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CF::PortAccessType& _s);
extern void operator<<=(::CORBA::Any& _a, CF::PortAccessType* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::PortAccessType*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::PortAccessType*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::Ports& _s);
void operator<<=(::CORBA::Any& _a, CF::Ports* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::Ports*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::Ports*& _sp);

inline void operator >>=(CF::ComponentEnumType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (CF::ComponentEnumType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= CF::PLATFORM_COMPONENT_FACTORY_COMPONENT) {
    _e = (CF::ComponentEnumType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, CF::ComponentEnumType _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::ComponentEnumType& _s);

extern void operator<<=(::CORBA::Any& _a, const CF::ComponentType& _s);
extern void operator<<=(::CORBA::Any& _a, CF::ComponentType* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::ComponentType*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::ComponentType*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::ObjectSequence& _s);
void operator<<=(::CORBA::Any& _a, CF::ObjectSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::ObjectSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::ObjectSequence*& _sp);





#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_CFCommonTypes
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_CFCommonTypes
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_CFCommonTypes
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_CFCommonTypes
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_CFCommonTypes
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_CFCommonTypes
#endif

#endif  // __CFCommonTypes_hh__

