// This file is generated by omniidl (C++ backend)- omniORB_4_2. Do not edit.
#ifndef __AdditionalTypes_hh__
#define __AdditionalTypes_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_AdditionalTypes
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_AdditionalTypes
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_AdditionalTypes
#endif






#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif



_CORBA_MODULE PortTypes

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_DoubleSequence;

  class DoubleSequence_var;

  class DoubleSequence : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 >  {
  public:
    typedef DoubleSequence_var _var_type;
    inline DoubleSequence() {}
    inline DoubleSequence(const DoubleSequence& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_s) {}

    inline DoubleSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_max) {}
    inline DoubleSequence(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Double* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_max, _len, _val, _rel) {}

  

    inline DoubleSequence& operator = (const DoubleSequence& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > ::operator=(_s);
      return *this;
    }
  };

  class DoubleSequence_out;

  class DoubleSequence_var {
  public:
    inline DoubleSequence_var() : _pd_seq(0) {}
    inline DoubleSequence_var(DoubleSequence* _s) : _pd_seq(_s) {}
    inline DoubleSequence_var(const DoubleSequence_var& _s) {
      if (_s._pd_seq)  _pd_seq = new DoubleSequence(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~DoubleSequence_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline DoubleSequence_var& operator = (DoubleSequence* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline DoubleSequence_var& operator = (const DoubleSequence_var& _s) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new DoubleSequence;
        *_pd_seq = *_s._pd_seq;
      } else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::Double& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline DoubleSequence* operator -> () { return _pd_seq; }
    inline const DoubleSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator DoubleSequence& () const { return *_pd_seq; }
#else
    inline operator const DoubleSequence& () const { return *_pd_seq; }
    inline operator DoubleSequence& () { return *_pd_seq; }
#endif
      
    inline const DoubleSequence& in() const { return *_pd_seq; }
    inline DoubleSequence&       inout()    { return *_pd_seq; }
    inline DoubleSequence*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline DoubleSequence* _retn() { DoubleSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class DoubleSequence_out;
    
  private:
    DoubleSequence* _pd_seq;
  };

  class DoubleSequence_out {
  public:
    inline DoubleSequence_out(DoubleSequence*& _s) : _data(_s) { _data = 0; }
    inline DoubleSequence_out(DoubleSequence_var& _s)
      : _data(_s._pd_seq) { _s = (DoubleSequence*) 0; }
    inline DoubleSequence_out(const DoubleSequence_out& _s) : _data(_s._data) {}
    inline DoubleSequence_out& operator = (const DoubleSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline DoubleSequence_out& operator = (DoubleSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator DoubleSequence*&()  { return _data; }
    inline DoubleSequence*& ptr()       { return _data; }
    inline DoubleSequence* operator->() { return _data; }

    inline ::CORBA::Double& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    DoubleSequence*& _data;

  private:
    DoubleSequence_out();
    DoubleSequence_out& operator=(const DoubleSequence_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_FloatSequence;

  class FloatSequence_var;

  class FloatSequence : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Float, 4, 4 >  {
  public:
    typedef FloatSequence_var _var_type;
    inline FloatSequence() {}
    inline FloatSequence(const FloatSequence& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Float, 4, 4 > (_s) {}

    inline FloatSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Float, 4, 4 > (_max) {}
    inline FloatSequence(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Float* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Float, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline FloatSequence& operator = (const FloatSequence& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Float, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class FloatSequence_out;

  class FloatSequence_var {
  public:
    inline FloatSequence_var() : _pd_seq(0) {}
    inline FloatSequence_var(FloatSequence* _s) : _pd_seq(_s) {}
    inline FloatSequence_var(const FloatSequence_var& _s) {
      if (_s._pd_seq)  _pd_seq = new FloatSequence(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~FloatSequence_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline FloatSequence_var& operator = (FloatSequence* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline FloatSequence_var& operator = (const FloatSequence_var& _s) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new FloatSequence;
        *_pd_seq = *_s._pd_seq;
      } else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::Float& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline FloatSequence* operator -> () { return _pd_seq; }
    inline const FloatSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator FloatSequence& () const { return *_pd_seq; }
#else
    inline operator const FloatSequence& () const { return *_pd_seq; }
    inline operator FloatSequence& () { return *_pd_seq; }
#endif
      
    inline const FloatSequence& in() const { return *_pd_seq; }
    inline FloatSequence&       inout()    { return *_pd_seq; }
    inline FloatSequence*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline FloatSequence* _retn() { FloatSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class FloatSequence_out;
    
  private:
    FloatSequence* _pd_seq;
  };

  class FloatSequence_out {
  public:
    inline FloatSequence_out(FloatSequence*& _s) : _data(_s) { _data = 0; }
    inline FloatSequence_out(FloatSequence_var& _s)
      : _data(_s._pd_seq) { _s = (FloatSequence*) 0; }
    inline FloatSequence_out(const FloatSequence_out& _s) : _data(_s._data) {}
    inline FloatSequence_out& operator = (const FloatSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline FloatSequence_out& operator = (FloatSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator FloatSequence*&()  { return _data; }
    inline FloatSequence*& ptr()       { return _data; }
    inline FloatSequence* operator->() { return _data; }

    inline ::CORBA::Float& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    FloatSequence*& _data;

  private:
    FloatSequence_out();
    FloatSequence_out& operator=(const FloatSequence_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LongLongSequence;

  class LongLongSequence_var;

  class LongLongSequence : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::LongLong, 8, 8 >  {
  public:
    typedef LongLongSequence_var _var_type;
    inline LongLongSequence() {}
    inline LongLongSequence(const LongLongSequence& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::LongLong, 8, 8 > (_s) {}

    inline LongLongSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::LongLong, 8, 8 > (_max) {}
    inline LongLongSequence(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::LongLong* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::LongLong, 8, 8 > (_max, _len, _val, _rel) {}

  

    inline LongLongSequence& operator = (const LongLongSequence& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::LongLong, 8, 8 > ::operator=(_s);
      return *this;
    }
  };

  class LongLongSequence_out;

  class LongLongSequence_var {
  public:
    inline LongLongSequence_var() : _pd_seq(0) {}
    inline LongLongSequence_var(LongLongSequence* _s) : _pd_seq(_s) {}
    inline LongLongSequence_var(const LongLongSequence_var& _s) {
      if (_s._pd_seq)  _pd_seq = new LongLongSequence(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~LongLongSequence_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline LongLongSequence_var& operator = (LongLongSequence* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline LongLongSequence_var& operator = (const LongLongSequence_var& _s) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new LongLongSequence;
        *_pd_seq = *_s._pd_seq;
      } else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::LongLong& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline LongLongSequence* operator -> () { return _pd_seq; }
    inline const LongLongSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator LongLongSequence& () const { return *_pd_seq; }
#else
    inline operator const LongLongSequence& () const { return *_pd_seq; }
    inline operator LongLongSequence& () { return *_pd_seq; }
#endif
      
    inline const LongLongSequence& in() const { return *_pd_seq; }
    inline LongLongSequence&       inout()    { return *_pd_seq; }
    inline LongLongSequence*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline LongLongSequence* _retn() { LongLongSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class LongLongSequence_out;
    
  private:
    LongLongSequence* _pd_seq;
  };

  class LongLongSequence_out {
  public:
    inline LongLongSequence_out(LongLongSequence*& _s) : _data(_s) { _data = 0; }
    inline LongLongSequence_out(LongLongSequence_var& _s)
      : _data(_s._pd_seq) { _s = (LongLongSequence*) 0; }
    inline LongLongSequence_out(const LongLongSequence_out& _s) : _data(_s._data) {}
    inline LongLongSequence_out& operator = (const LongLongSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline LongLongSequence_out& operator = (LongLongSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator LongLongSequence*&()  { return _data; }
    inline LongLongSequence*& ptr()       { return _data; }
    inline LongLongSequence* operator->() { return _data; }

    inline ::CORBA::LongLong& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    LongLongSequence*& _data;

  private:
    LongLongSequence_out();
    LongLongSequence_out& operator=(const LongLongSequence_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_UlongSequence;

  class UlongSequence_var;

  class UlongSequence : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::ULong, 4, 4 >  {
  public:
    typedef UlongSequence_var _var_type;
    inline UlongSequence() {}
    inline UlongSequence(const UlongSequence& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::ULong, 4, 4 > (_s) {}

    inline UlongSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::ULong, 4, 4 > (_max) {}
    inline UlongSequence(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::ULong* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::ULong, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline UlongSequence& operator = (const UlongSequence& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::ULong, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class UlongSequence_out;

  class UlongSequence_var {
  public:
    inline UlongSequence_var() : _pd_seq(0) {}
    inline UlongSequence_var(UlongSequence* _s) : _pd_seq(_s) {}
    inline UlongSequence_var(const UlongSequence_var& _s) {
      if (_s._pd_seq)  _pd_seq = new UlongSequence(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~UlongSequence_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline UlongSequence_var& operator = (UlongSequence* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline UlongSequence_var& operator = (const UlongSequence_var& _s) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new UlongSequence;
        *_pd_seq = *_s._pd_seq;
      } else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::ULong& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline UlongSequence* operator -> () { return _pd_seq; }
    inline const UlongSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator UlongSequence& () const { return *_pd_seq; }
#else
    inline operator const UlongSequence& () const { return *_pd_seq; }
    inline operator UlongSequence& () { return *_pd_seq; }
#endif
      
    inline const UlongSequence& in() const { return *_pd_seq; }
    inline UlongSequence&       inout()    { return *_pd_seq; }
    inline UlongSequence*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline UlongSequence* _retn() { UlongSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class UlongSequence_out;
    
  private:
    UlongSequence* _pd_seq;
  };

  class UlongSequence_out {
  public:
    inline UlongSequence_out(UlongSequence*& _s) : _data(_s) { _data = 0; }
    inline UlongSequence_out(UlongSequence_var& _s)
      : _data(_s._pd_seq) { _s = (UlongSequence*) 0; }
    inline UlongSequence_out(const UlongSequence_out& _s) : _data(_s._data) {}
    inline UlongSequence_out& operator = (const UlongSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline UlongSequence_out& operator = (UlongSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator UlongSequence*&()  { return _data; }
    inline UlongSequence*& ptr()       { return _data; }
    inline UlongSequence* operator->() { return _data; }

    inline ::CORBA::ULong& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    UlongSequence*& _data;

  private:
    UlongSequence_out();
    UlongSequence_out& operator=(const UlongSequence_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_UlongLongSequence;

  class UlongLongSequence_var;

  class UlongLongSequence : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::ULongLong, 8, 8 >  {
  public:
    typedef UlongLongSequence_var _var_type;
    inline UlongLongSequence() {}
    inline UlongLongSequence(const UlongLongSequence& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::ULongLong, 8, 8 > (_s) {}

    inline UlongLongSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::ULongLong, 8, 8 > (_max) {}
    inline UlongLongSequence(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::ULongLong* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::ULongLong, 8, 8 > (_max, _len, _val, _rel) {}

  

    inline UlongLongSequence& operator = (const UlongLongSequence& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::ULongLong, 8, 8 > ::operator=(_s);
      return *this;
    }
  };

  class UlongLongSequence_out;

  class UlongLongSequence_var {
  public:
    inline UlongLongSequence_var() : _pd_seq(0) {}
    inline UlongLongSequence_var(UlongLongSequence* _s) : _pd_seq(_s) {}
    inline UlongLongSequence_var(const UlongLongSequence_var& _s) {
      if (_s._pd_seq)  _pd_seq = new UlongLongSequence(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~UlongLongSequence_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline UlongLongSequence_var& operator = (UlongLongSequence* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline UlongLongSequence_var& operator = (const UlongLongSequence_var& _s) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new UlongLongSequence;
        *_pd_seq = *_s._pd_seq;
      } else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::ULongLong& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline UlongLongSequence* operator -> () { return _pd_seq; }
    inline const UlongLongSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator UlongLongSequence& () const { return *_pd_seq; }
#else
    inline operator const UlongLongSequence& () const { return *_pd_seq; }
    inline operator UlongLongSequence& () { return *_pd_seq; }
#endif
      
    inline const UlongLongSequence& in() const { return *_pd_seq; }
    inline UlongLongSequence&       inout()    { return *_pd_seq; }
    inline UlongLongSequence*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline UlongLongSequence* _retn() { UlongLongSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class UlongLongSequence_out;
    
  private:
    UlongLongSequence* _pd_seq;
  };

  class UlongLongSequence_out {
  public:
    inline UlongLongSequence_out(UlongLongSequence*& _s) : _data(_s) { _data = 0; }
    inline UlongLongSequence_out(UlongLongSequence_var& _s)
      : _data(_s._pd_seq) { _s = (UlongLongSequence*) 0; }
    inline UlongLongSequence_out(const UlongLongSequence_out& _s) : _data(_s._data) {}
    inline UlongLongSequence_out& operator = (const UlongLongSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline UlongLongSequence_out& operator = (UlongLongSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator UlongLongSequence*&()  { return _data; }
    inline UlongLongSequence*& ptr()       { return _data; }
    inline UlongLongSequence* operator->() { return _data; }

    inline ::CORBA::ULongLong& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    UlongLongSequence*& _data;

  private:
    UlongLongSequence_out();
    UlongLongSequence_out& operator=(const UlongLongSequence_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ShortSequence;

  class ShortSequence_var;

  class ShortSequence : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Short, 2, 2 >  {
  public:
    typedef ShortSequence_var _var_type;
    inline ShortSequence() {}
    inline ShortSequence(const ShortSequence& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Short, 2, 2 > (_s) {}

    inline ShortSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Short, 2, 2 > (_max) {}
    inline ShortSequence(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Short* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Short, 2, 2 > (_max, _len, _val, _rel) {}

  

    inline ShortSequence& operator = (const ShortSequence& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Short, 2, 2 > ::operator=(_s);
      return *this;
    }
  };

  class ShortSequence_out;

  class ShortSequence_var {
  public:
    inline ShortSequence_var() : _pd_seq(0) {}
    inline ShortSequence_var(ShortSequence* _s) : _pd_seq(_s) {}
    inline ShortSequence_var(const ShortSequence_var& _s) {
      if (_s._pd_seq)  _pd_seq = new ShortSequence(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~ShortSequence_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline ShortSequence_var& operator = (ShortSequence* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline ShortSequence_var& operator = (const ShortSequence_var& _s) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new ShortSequence;
        *_pd_seq = *_s._pd_seq;
      } else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::Short& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline ShortSequence* operator -> () { return _pd_seq; }
    inline const ShortSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator ShortSequence& () const { return *_pd_seq; }
#else
    inline operator const ShortSequence& () const { return *_pd_seq; }
    inline operator ShortSequence& () { return *_pd_seq; }
#endif
      
    inline const ShortSequence& in() const { return *_pd_seq; }
    inline ShortSequence&       inout()    { return *_pd_seq; }
    inline ShortSequence*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline ShortSequence* _retn() { ShortSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class ShortSequence_out;
    
  private:
    ShortSequence* _pd_seq;
  };

  class ShortSequence_out {
  public:
    inline ShortSequence_out(ShortSequence*& _s) : _data(_s) { _data = 0; }
    inline ShortSequence_out(ShortSequence_var& _s)
      : _data(_s._pd_seq) { _s = (ShortSequence*) 0; }
    inline ShortSequence_out(const ShortSequence_out& _s) : _data(_s._data) {}
    inline ShortSequence_out& operator = (const ShortSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline ShortSequence_out& operator = (ShortSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator ShortSequence*&()  { return _data; }
    inline ShortSequence*& ptr()       { return _data; }
    inline ShortSequence* operator->() { return _data; }

    inline ::CORBA::Short& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    ShortSequence*& _data;

  private:
    ShortSequence_out();
    ShortSequence_out& operator=(const ShortSequence_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_UshortSequence;

  class UshortSequence_var;

  class UshortSequence : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::UShort, 2, 2 >  {
  public:
    typedef UshortSequence_var _var_type;
    inline UshortSequence() {}
    inline UshortSequence(const UshortSequence& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::UShort, 2, 2 > (_s) {}

    inline UshortSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::UShort, 2, 2 > (_max) {}
    inline UshortSequence(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::UShort* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::UShort, 2, 2 > (_max, _len, _val, _rel) {}

  

    inline UshortSequence& operator = (const UshortSequence& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::UShort, 2, 2 > ::operator=(_s);
      return *this;
    }
  };

  class UshortSequence_out;

  class UshortSequence_var {
  public:
    inline UshortSequence_var() : _pd_seq(0) {}
    inline UshortSequence_var(UshortSequence* _s) : _pd_seq(_s) {}
    inline UshortSequence_var(const UshortSequence_var& _s) {
      if (_s._pd_seq)  _pd_seq = new UshortSequence(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~UshortSequence_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline UshortSequence_var& operator = (UshortSequence* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline UshortSequence_var& operator = (const UshortSequence_var& _s) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new UshortSequence;
        *_pd_seq = *_s._pd_seq;
      } else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::UShort& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline UshortSequence* operator -> () { return _pd_seq; }
    inline const UshortSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator UshortSequence& () const { return *_pd_seq; }
#else
    inline operator const UshortSequence& () const { return *_pd_seq; }
    inline operator UshortSequence& () { return *_pd_seq; }
#endif
      
    inline const UshortSequence& in() const { return *_pd_seq; }
    inline UshortSequence&       inout()    { return *_pd_seq; }
    inline UshortSequence*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline UshortSequence* _retn() { UshortSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class UshortSequence_out;
    
  private:
    UshortSequence* _pd_seq;
  };

  class UshortSequence_out {
  public:
    inline UshortSequence_out(UshortSequence*& _s) : _data(_s) { _data = 0; }
    inline UshortSequence_out(UshortSequence_var& _s)
      : _data(_s._pd_seq) { _s = (UshortSequence*) 0; }
    inline UshortSequence_out(const UshortSequence_out& _s) : _data(_s._data) {}
    inline UshortSequence_out& operator = (const UshortSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline UshortSequence_out& operator = (UshortSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator UshortSequence*&()  { return _data; }
    inline UshortSequence*& ptr()       { return _data; }
    inline UshortSequence* operator->() { return _data; }

    inline ::CORBA::UShort& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    UshortSequence*& _data;

  private:
    UshortSequence_out();
    UshortSequence_out& operator=(const UshortSequence_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_CharSequence;

  class CharSequence_var;

  class CharSequence : public _CORBA_Unbounded_Sequence_Char {
  public:
    typedef CharSequence_var _var_type;
    inline CharSequence() {}
    inline CharSequence(const CharSequence& _s)
      : _CORBA_Unbounded_Sequence_Char(_s) {}

    inline CharSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_Char(_max) {}
    inline CharSequence(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Char* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_Char(_max, _len, _val, _rel) {}

  

    inline CharSequence& operator = (const CharSequence& _s) {
      _CORBA_Unbounded_Sequence_Char::operator=(_s);
      return *this;
    }
  };

  class CharSequence_out;

  class CharSequence_var {
  public:
    inline CharSequence_var() : _pd_seq(0) {}
    inline CharSequence_var(CharSequence* _s) : _pd_seq(_s) {}
    inline CharSequence_var(const CharSequence_var& _s) {
      if (_s._pd_seq)  _pd_seq = new CharSequence(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~CharSequence_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline CharSequence_var& operator = (CharSequence* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline CharSequence_var& operator = (const CharSequence_var& _s) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new CharSequence;
        *_pd_seq = *_s._pd_seq;
      } else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::Char& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline CharSequence* operator -> () { return _pd_seq; }
    inline const CharSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator CharSequence& () const { return *_pd_seq; }
#else
    inline operator const CharSequence& () const { return *_pd_seq; }
    inline operator CharSequence& () { return *_pd_seq; }
#endif
      
    inline const CharSequence& in() const { return *_pd_seq; }
    inline CharSequence&       inout()    { return *_pd_seq; }
    inline CharSequence*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline CharSequence* _retn() { CharSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class CharSequence_out;
    
  private:
    CharSequence* _pd_seq;
  };

  class CharSequence_out {
  public:
    inline CharSequence_out(CharSequence*& _s) : _data(_s) { _data = 0; }
    inline CharSequence_out(CharSequence_var& _s)
      : _data(_s._pd_seq) { _s = (CharSequence*) 0; }
    inline CharSequence_out(const CharSequence_out& _s) : _data(_s._data) {}
    inline CharSequence_out& operator = (const CharSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline CharSequence_out& operator = (CharSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator CharSequence*&()  { return _data; }
    inline CharSequence*& ptr()       { return _data; }
    inline CharSequence* operator->() { return _data; }

    inline ::CORBA::Char& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    CharSequence*& _data;

  private:
    CharSequence_out();
    CharSequence_out& operator=(const CharSequence_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LongSequence;

  class LongSequence_var;

  class LongSequence : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef LongSequence_var _var_type;
    inline LongSequence() {}
    inline LongSequence(const LongSequence& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline LongSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline LongSequence(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline LongSequence& operator = (const LongSequence& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class LongSequence_out;

  class LongSequence_var {
  public:
    inline LongSequence_var() : _pd_seq(0) {}
    inline LongSequence_var(LongSequence* _s) : _pd_seq(_s) {}
    inline LongSequence_var(const LongSequence_var& _s) {
      if (_s._pd_seq)  _pd_seq = new LongSequence(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~LongSequence_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline LongSequence_var& operator = (LongSequence* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline LongSequence_var& operator = (const LongSequence_var& _s) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new LongSequence;
        *_pd_seq = *_s._pd_seq;
      } else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline LongSequence* operator -> () { return _pd_seq; }
    inline const LongSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator LongSequence& () const { return *_pd_seq; }
#else
    inline operator const LongSequence& () const { return *_pd_seq; }
    inline operator LongSequence& () { return *_pd_seq; }
#endif
      
    inline const LongSequence& in() const { return *_pd_seq; }
    inline LongSequence&       inout()    { return *_pd_seq; }
    inline LongSequence*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline LongSequence* _retn() { LongSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class LongSequence_out;
    
  private:
    LongSequence* _pd_seq;
  };

  class LongSequence_out {
  public:
    inline LongSequence_out(LongSequence*& _s) : _data(_s) { _data = 0; }
    inline LongSequence_out(LongSequence_var& _s)
      : _data(_s._pd_seq) { _s = (LongSequence*) 0; }
    inline LongSequence_out(const LongSequence_out& _s) : _data(_s._data) {}
    inline LongSequence_out& operator = (const LongSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline LongSequence_out& operator = (LongSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator LongSequence*&()  { return _data; }
    inline LongSequence*& ptr()       { return _data; }
    inline LongSequence* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    LongSequence*& _data;

  private:
    LongSequence_out();
    LongSequence_out& operator=(const LongSequence_var&);
  };

_CORBA_MODULE_END

_CORBA_MODULE CF

_CORBA_MODULE_BEG

  struct complexDouble {
    typedef _CORBA_ConstrType_Fix_Var<complexDouble> _var_type;

    
    ::CORBA::Double real;

    ::CORBA::Double imag;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef complexDouble::_var_type complexDouble_var;

  typedef complexDouble& complexDouble_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_complexDouble;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_complexDoubleSeq;

  class complexDoubleSeq_var;

  class complexDoubleSeq : public _CORBA_Unbounded_Sequence< complexDouble >  {
  public:
    typedef complexDoubleSeq_var _var_type;
    inline complexDoubleSeq() {}
    inline complexDoubleSeq(const complexDoubleSeq& _s)
      : _CORBA_Unbounded_Sequence< complexDouble > (_s) {}

    inline complexDoubleSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< complexDouble > (_max) {}
    inline complexDoubleSeq(_CORBA_ULong _max, _CORBA_ULong _len, complexDouble* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< complexDouble > (_max, _len, _val, _rel) {}

  

    inline complexDoubleSeq& operator = (const complexDoubleSeq& _s) {
      _CORBA_Unbounded_Sequence< complexDouble > ::operator=(_s);
      return *this;
    }
  };

  class complexDoubleSeq_out;

  class complexDoubleSeq_var {
  public:
    inline complexDoubleSeq_var() : _pd_seq(0) {}
    inline complexDoubleSeq_var(complexDoubleSeq* _s) : _pd_seq(_s) {}
    inline complexDoubleSeq_var(const complexDoubleSeq_var& _s) {
      if (_s._pd_seq)  _pd_seq = new complexDoubleSeq(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~complexDoubleSeq_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline complexDoubleSeq_var& operator = (complexDoubleSeq* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline complexDoubleSeq_var& operator = (const complexDoubleSeq_var& _s) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new complexDoubleSeq;
        *_pd_seq = *_s._pd_seq;
      } else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline complexDouble& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline complexDoubleSeq* operator -> () { return _pd_seq; }
    inline const complexDoubleSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator complexDoubleSeq& () const { return *_pd_seq; }
#else
    inline operator const complexDoubleSeq& () const { return *_pd_seq; }
    inline operator complexDoubleSeq& () { return *_pd_seq; }
#endif
      
    inline const complexDoubleSeq& in() const { return *_pd_seq; }
    inline complexDoubleSeq&       inout()    { return *_pd_seq; }
    inline complexDoubleSeq*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline complexDoubleSeq* _retn() { complexDoubleSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class complexDoubleSeq_out;
    
  private:
    complexDoubleSeq* _pd_seq;
  };

  class complexDoubleSeq_out {
  public:
    inline complexDoubleSeq_out(complexDoubleSeq*& _s) : _data(_s) { _data = 0; }
    inline complexDoubleSeq_out(complexDoubleSeq_var& _s)
      : _data(_s._pd_seq) { _s = (complexDoubleSeq*) 0; }
    inline complexDoubleSeq_out(const complexDoubleSeq_out& _s) : _data(_s._data) {}
    inline complexDoubleSeq_out& operator = (const complexDoubleSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline complexDoubleSeq_out& operator = (complexDoubleSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator complexDoubleSeq*&()  { return _data; }
    inline complexDoubleSeq*& ptr()       { return _data; }
    inline complexDoubleSeq* operator->() { return _data; }

    inline complexDouble& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    complexDoubleSeq*& _data;

  private:
    complexDoubleSeq_out();
    complexDoubleSeq_out& operator=(const complexDoubleSeq_var&);
  };

  struct complexFloat {
    typedef _CORBA_ConstrType_Fix_Var<complexFloat> _var_type;

    
    ::CORBA::Float real;

    ::CORBA::Float imag;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef complexFloat::_var_type complexFloat_var;

  typedef complexFloat& complexFloat_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_complexFloat;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_complexFloatSeq;

  class complexFloatSeq_var;

  class complexFloatSeq : public _CORBA_Unbounded_Sequence< complexFloat >  {
  public:
    typedef complexFloatSeq_var _var_type;
    inline complexFloatSeq() {}
    inline complexFloatSeq(const complexFloatSeq& _s)
      : _CORBA_Unbounded_Sequence< complexFloat > (_s) {}

    inline complexFloatSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< complexFloat > (_max) {}
    inline complexFloatSeq(_CORBA_ULong _max, _CORBA_ULong _len, complexFloat* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< complexFloat > (_max, _len, _val, _rel) {}

  

    inline complexFloatSeq& operator = (const complexFloatSeq& _s) {
      _CORBA_Unbounded_Sequence< complexFloat > ::operator=(_s);
      return *this;
    }
  };

  class complexFloatSeq_out;

  class complexFloatSeq_var {
  public:
    inline complexFloatSeq_var() : _pd_seq(0) {}
    inline complexFloatSeq_var(complexFloatSeq* _s) : _pd_seq(_s) {}
    inline complexFloatSeq_var(const complexFloatSeq_var& _s) {
      if (_s._pd_seq)  _pd_seq = new complexFloatSeq(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~complexFloatSeq_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline complexFloatSeq_var& operator = (complexFloatSeq* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline complexFloatSeq_var& operator = (const complexFloatSeq_var& _s) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new complexFloatSeq;
        *_pd_seq = *_s._pd_seq;
      } else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline complexFloat& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline complexFloatSeq* operator -> () { return _pd_seq; }
    inline const complexFloatSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator complexFloatSeq& () const { return *_pd_seq; }
#else
    inline operator const complexFloatSeq& () const { return *_pd_seq; }
    inline operator complexFloatSeq& () { return *_pd_seq; }
#endif
      
    inline const complexFloatSeq& in() const { return *_pd_seq; }
    inline complexFloatSeq&       inout()    { return *_pd_seq; }
    inline complexFloatSeq*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline complexFloatSeq* _retn() { complexFloatSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class complexFloatSeq_out;
    
  private:
    complexFloatSeq* _pd_seq;
  };

  class complexFloatSeq_out {
  public:
    inline complexFloatSeq_out(complexFloatSeq*& _s) : _data(_s) { _data = 0; }
    inline complexFloatSeq_out(complexFloatSeq_var& _s)
      : _data(_s._pd_seq) { _s = (complexFloatSeq*) 0; }
    inline complexFloatSeq_out(const complexFloatSeq_out& _s) : _data(_s._data) {}
    inline complexFloatSeq_out& operator = (const complexFloatSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline complexFloatSeq_out& operator = (complexFloatSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator complexFloatSeq*&()  { return _data; }
    inline complexFloatSeq*& ptr()       { return _data; }
    inline complexFloatSeq* operator->() { return _data; }

    inline complexFloat& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    complexFloatSeq*& _data;

  private:
    complexFloatSeq_out();
    complexFloatSeq_out& operator=(const complexFloatSeq_var&);
  };

  struct complexBoolean {
    typedef _CORBA_ConstrType_Fix_Var<complexBoolean> _var_type;

    
    ::CORBA::Boolean real;

    ::CORBA::Boolean imag;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef complexBoolean::_var_type complexBoolean_var;

  typedef complexBoolean& complexBoolean_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_complexBoolean;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_complexBooleanSeq;

  class complexBooleanSeq_var;

  class complexBooleanSeq : public _CORBA_Unbounded_Sequence< complexBoolean >  {
  public:
    typedef complexBooleanSeq_var _var_type;
    inline complexBooleanSeq() {}
    inline complexBooleanSeq(const complexBooleanSeq& _s)
      : _CORBA_Unbounded_Sequence< complexBoolean > (_s) {}

    inline complexBooleanSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< complexBoolean > (_max) {}
    inline complexBooleanSeq(_CORBA_ULong _max, _CORBA_ULong _len, complexBoolean* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< complexBoolean > (_max, _len, _val, _rel) {}

  

    inline complexBooleanSeq& operator = (const complexBooleanSeq& _s) {
      _CORBA_Unbounded_Sequence< complexBoolean > ::operator=(_s);
      return *this;
    }
  };

  class complexBooleanSeq_out;

  class complexBooleanSeq_var {
  public:
    inline complexBooleanSeq_var() : _pd_seq(0) {}
    inline complexBooleanSeq_var(complexBooleanSeq* _s) : _pd_seq(_s) {}
    inline complexBooleanSeq_var(const complexBooleanSeq_var& _s) {
      if (_s._pd_seq)  _pd_seq = new complexBooleanSeq(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~complexBooleanSeq_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline complexBooleanSeq_var& operator = (complexBooleanSeq* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline complexBooleanSeq_var& operator = (const complexBooleanSeq_var& _s) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new complexBooleanSeq;
        *_pd_seq = *_s._pd_seq;
      } else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline complexBoolean& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline complexBooleanSeq* operator -> () { return _pd_seq; }
    inline const complexBooleanSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator complexBooleanSeq& () const { return *_pd_seq; }
#else
    inline operator const complexBooleanSeq& () const { return *_pd_seq; }
    inline operator complexBooleanSeq& () { return *_pd_seq; }
#endif
      
    inline const complexBooleanSeq& in() const { return *_pd_seq; }
    inline complexBooleanSeq&       inout()    { return *_pd_seq; }
    inline complexBooleanSeq*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline complexBooleanSeq* _retn() { complexBooleanSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class complexBooleanSeq_out;
    
  private:
    complexBooleanSeq* _pd_seq;
  };

  class complexBooleanSeq_out {
  public:
    inline complexBooleanSeq_out(complexBooleanSeq*& _s) : _data(_s) { _data = 0; }
    inline complexBooleanSeq_out(complexBooleanSeq_var& _s)
      : _data(_s._pd_seq) { _s = (complexBooleanSeq*) 0; }
    inline complexBooleanSeq_out(const complexBooleanSeq_out& _s) : _data(_s._data) {}
    inline complexBooleanSeq_out& operator = (const complexBooleanSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline complexBooleanSeq_out& operator = (complexBooleanSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator complexBooleanSeq*&()  { return _data; }
    inline complexBooleanSeq*& ptr()       { return _data; }
    inline complexBooleanSeq* operator->() { return _data; }

    inline complexBoolean& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    complexBooleanSeq*& _data;

  private:
    complexBooleanSeq_out();
    complexBooleanSeq_out& operator=(const complexBooleanSeq_var&);
  };

  struct complexULong {
    typedef _CORBA_ConstrType_Fix_Var<complexULong> _var_type;

    
    ::CORBA::ULong real;

    ::CORBA::ULong imag;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef complexULong::_var_type complexULong_var;

  typedef complexULong& complexULong_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_complexULong;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_complexULongSeq;

  class complexULongSeq_var;

  class complexULongSeq : public _CORBA_Unbounded_Sequence< complexULong >  {
  public:
    typedef complexULongSeq_var _var_type;
    inline complexULongSeq() {}
    inline complexULongSeq(const complexULongSeq& _s)
      : _CORBA_Unbounded_Sequence< complexULong > (_s) {}

    inline complexULongSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< complexULong > (_max) {}
    inline complexULongSeq(_CORBA_ULong _max, _CORBA_ULong _len, complexULong* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< complexULong > (_max, _len, _val, _rel) {}

  

    inline complexULongSeq& operator = (const complexULongSeq& _s) {
      _CORBA_Unbounded_Sequence< complexULong > ::operator=(_s);
      return *this;
    }
  };

  class complexULongSeq_out;

  class complexULongSeq_var {
  public:
    inline complexULongSeq_var() : _pd_seq(0) {}
    inline complexULongSeq_var(complexULongSeq* _s) : _pd_seq(_s) {}
    inline complexULongSeq_var(const complexULongSeq_var& _s) {
      if (_s._pd_seq)  _pd_seq = new complexULongSeq(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~complexULongSeq_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline complexULongSeq_var& operator = (complexULongSeq* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline complexULongSeq_var& operator = (const complexULongSeq_var& _s) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new complexULongSeq;
        *_pd_seq = *_s._pd_seq;
      } else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline complexULong& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline complexULongSeq* operator -> () { return _pd_seq; }
    inline const complexULongSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator complexULongSeq& () const { return *_pd_seq; }
#else
    inline operator const complexULongSeq& () const { return *_pd_seq; }
    inline operator complexULongSeq& () { return *_pd_seq; }
#endif
      
    inline const complexULongSeq& in() const { return *_pd_seq; }
    inline complexULongSeq&       inout()    { return *_pd_seq; }
    inline complexULongSeq*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline complexULongSeq* _retn() { complexULongSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class complexULongSeq_out;
    
  private:
    complexULongSeq* _pd_seq;
  };

  class complexULongSeq_out {
  public:
    inline complexULongSeq_out(complexULongSeq*& _s) : _data(_s) { _data = 0; }
    inline complexULongSeq_out(complexULongSeq_var& _s)
      : _data(_s._pd_seq) { _s = (complexULongSeq*) 0; }
    inline complexULongSeq_out(const complexULongSeq_out& _s) : _data(_s._data) {}
    inline complexULongSeq_out& operator = (const complexULongSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline complexULongSeq_out& operator = (complexULongSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator complexULongSeq*&()  { return _data; }
    inline complexULongSeq*& ptr()       { return _data; }
    inline complexULongSeq* operator->() { return _data; }

    inline complexULong& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    complexULongSeq*& _data;

  private:
    complexULongSeq_out();
    complexULongSeq_out& operator=(const complexULongSeq_var&);
  };

  struct complexShort {
    typedef _CORBA_ConstrType_Fix_Var<complexShort> _var_type;

    
    ::CORBA::Short real;

    ::CORBA::Short imag;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef complexShort::_var_type complexShort_var;

  typedef complexShort& complexShort_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_complexShort;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_complexShortSeq;

  class complexShortSeq_var;

  class complexShortSeq : public _CORBA_Unbounded_Sequence< complexShort >  {
  public:
    typedef complexShortSeq_var _var_type;
    inline complexShortSeq() {}
    inline complexShortSeq(const complexShortSeq& _s)
      : _CORBA_Unbounded_Sequence< complexShort > (_s) {}

    inline complexShortSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< complexShort > (_max) {}
    inline complexShortSeq(_CORBA_ULong _max, _CORBA_ULong _len, complexShort* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< complexShort > (_max, _len, _val, _rel) {}

  

    inline complexShortSeq& operator = (const complexShortSeq& _s) {
      _CORBA_Unbounded_Sequence< complexShort > ::operator=(_s);
      return *this;
    }
  };

  class complexShortSeq_out;

  class complexShortSeq_var {
  public:
    inline complexShortSeq_var() : _pd_seq(0) {}
    inline complexShortSeq_var(complexShortSeq* _s) : _pd_seq(_s) {}
    inline complexShortSeq_var(const complexShortSeq_var& _s) {
      if (_s._pd_seq)  _pd_seq = new complexShortSeq(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~complexShortSeq_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline complexShortSeq_var& operator = (complexShortSeq* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline complexShortSeq_var& operator = (const complexShortSeq_var& _s) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new complexShortSeq;
        *_pd_seq = *_s._pd_seq;
      } else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline complexShort& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline complexShortSeq* operator -> () { return _pd_seq; }
    inline const complexShortSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator complexShortSeq& () const { return *_pd_seq; }
#else
    inline operator const complexShortSeq& () const { return *_pd_seq; }
    inline operator complexShortSeq& () { return *_pd_seq; }
#endif
      
    inline const complexShortSeq& in() const { return *_pd_seq; }
    inline complexShortSeq&       inout()    { return *_pd_seq; }
    inline complexShortSeq*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline complexShortSeq* _retn() { complexShortSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class complexShortSeq_out;
    
  private:
    complexShortSeq* _pd_seq;
  };

  class complexShortSeq_out {
  public:
    inline complexShortSeq_out(complexShortSeq*& _s) : _data(_s) { _data = 0; }
    inline complexShortSeq_out(complexShortSeq_var& _s)
      : _data(_s._pd_seq) { _s = (complexShortSeq*) 0; }
    inline complexShortSeq_out(const complexShortSeq_out& _s) : _data(_s._data) {}
    inline complexShortSeq_out& operator = (const complexShortSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline complexShortSeq_out& operator = (complexShortSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator complexShortSeq*&()  { return _data; }
    inline complexShortSeq*& ptr()       { return _data; }
    inline complexShortSeq* operator->() { return _data; }

    inline complexShort& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    complexShortSeq*& _data;

  private:
    complexShortSeq_out();
    complexShortSeq_out& operator=(const complexShortSeq_var&);
  };

  struct complexOctet {
    typedef _CORBA_ConstrType_Fix_Var<complexOctet> _var_type;

    
    ::CORBA::Octet real;

    ::CORBA::Octet imag;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef complexOctet::_var_type complexOctet_var;

  typedef complexOctet& complexOctet_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_complexOctet;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_complexOctetSeq;

  class complexOctetSeq_var;

  class complexOctetSeq : public _CORBA_Unbounded_Sequence< complexOctet >  {
  public:
    typedef complexOctetSeq_var _var_type;
    inline complexOctetSeq() {}
    inline complexOctetSeq(const complexOctetSeq& _s)
      : _CORBA_Unbounded_Sequence< complexOctet > (_s) {}

    inline complexOctetSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< complexOctet > (_max) {}
    inline complexOctetSeq(_CORBA_ULong _max, _CORBA_ULong _len, complexOctet* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< complexOctet > (_max, _len, _val, _rel) {}

  

    inline complexOctetSeq& operator = (const complexOctetSeq& _s) {
      _CORBA_Unbounded_Sequence< complexOctet > ::operator=(_s);
      return *this;
    }
  };

  class complexOctetSeq_out;

  class complexOctetSeq_var {
  public:
    inline complexOctetSeq_var() : _pd_seq(0) {}
    inline complexOctetSeq_var(complexOctetSeq* _s) : _pd_seq(_s) {}
    inline complexOctetSeq_var(const complexOctetSeq_var& _s) {
      if (_s._pd_seq)  _pd_seq = new complexOctetSeq(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~complexOctetSeq_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline complexOctetSeq_var& operator = (complexOctetSeq* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline complexOctetSeq_var& operator = (const complexOctetSeq_var& _s) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new complexOctetSeq;
        *_pd_seq = *_s._pd_seq;
      } else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline complexOctet& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline complexOctetSeq* operator -> () { return _pd_seq; }
    inline const complexOctetSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator complexOctetSeq& () const { return *_pd_seq; }
#else
    inline operator const complexOctetSeq& () const { return *_pd_seq; }
    inline operator complexOctetSeq& () { return *_pd_seq; }
#endif
      
    inline const complexOctetSeq& in() const { return *_pd_seq; }
    inline complexOctetSeq&       inout()    { return *_pd_seq; }
    inline complexOctetSeq*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline complexOctetSeq* _retn() { complexOctetSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class complexOctetSeq_out;
    
  private:
    complexOctetSeq* _pd_seq;
  };

  class complexOctetSeq_out {
  public:
    inline complexOctetSeq_out(complexOctetSeq*& _s) : _data(_s) { _data = 0; }
    inline complexOctetSeq_out(complexOctetSeq_var& _s)
      : _data(_s._pd_seq) { _s = (complexOctetSeq*) 0; }
    inline complexOctetSeq_out(const complexOctetSeq_out& _s) : _data(_s._data) {}
    inline complexOctetSeq_out& operator = (const complexOctetSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline complexOctetSeq_out& operator = (complexOctetSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator complexOctetSeq*&()  { return _data; }
    inline complexOctetSeq*& ptr()       { return _data; }
    inline complexOctetSeq* operator->() { return _data; }

    inline complexOctet& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    complexOctetSeq*& _data;

  private:
    complexOctetSeq_out();
    complexOctetSeq_out& operator=(const complexOctetSeq_var&);
  };

  struct complexChar {
    typedef _CORBA_ConstrType_Fix_Var<complexChar> _var_type;

    
    ::CORBA::Char real;

    ::CORBA::Char imag;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef complexChar::_var_type complexChar_var;

  typedef complexChar& complexChar_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_complexChar;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_complexCharSeq;

  class complexCharSeq_var;

  class complexCharSeq : public _CORBA_Unbounded_Sequence< complexChar >  {
  public:
    typedef complexCharSeq_var _var_type;
    inline complexCharSeq() {}
    inline complexCharSeq(const complexCharSeq& _s)
      : _CORBA_Unbounded_Sequence< complexChar > (_s) {}

    inline complexCharSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< complexChar > (_max) {}
    inline complexCharSeq(_CORBA_ULong _max, _CORBA_ULong _len, complexChar* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< complexChar > (_max, _len, _val, _rel) {}

  

    inline complexCharSeq& operator = (const complexCharSeq& _s) {
      _CORBA_Unbounded_Sequence< complexChar > ::operator=(_s);
      return *this;
    }
  };

  class complexCharSeq_out;

  class complexCharSeq_var {
  public:
    inline complexCharSeq_var() : _pd_seq(0) {}
    inline complexCharSeq_var(complexCharSeq* _s) : _pd_seq(_s) {}
    inline complexCharSeq_var(const complexCharSeq_var& _s) {
      if (_s._pd_seq)  _pd_seq = new complexCharSeq(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~complexCharSeq_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline complexCharSeq_var& operator = (complexCharSeq* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline complexCharSeq_var& operator = (const complexCharSeq_var& _s) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new complexCharSeq;
        *_pd_seq = *_s._pd_seq;
      } else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline complexChar& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline complexCharSeq* operator -> () { return _pd_seq; }
    inline const complexCharSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator complexCharSeq& () const { return *_pd_seq; }
#else
    inline operator const complexCharSeq& () const { return *_pd_seq; }
    inline operator complexCharSeq& () { return *_pd_seq; }
#endif
      
    inline const complexCharSeq& in() const { return *_pd_seq; }
    inline complexCharSeq&       inout()    { return *_pd_seq; }
    inline complexCharSeq*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline complexCharSeq* _retn() { complexCharSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class complexCharSeq_out;
    
  private:
    complexCharSeq* _pd_seq;
  };

  class complexCharSeq_out {
  public:
    inline complexCharSeq_out(complexCharSeq*& _s) : _data(_s) { _data = 0; }
    inline complexCharSeq_out(complexCharSeq_var& _s)
      : _data(_s._pd_seq) { _s = (complexCharSeq*) 0; }
    inline complexCharSeq_out(const complexCharSeq_out& _s) : _data(_s._data) {}
    inline complexCharSeq_out& operator = (const complexCharSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline complexCharSeq_out& operator = (complexCharSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator complexCharSeq*&()  { return _data; }
    inline complexCharSeq*& ptr()       { return _data; }
    inline complexCharSeq* operator->() { return _data; }

    inline complexChar& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    complexCharSeq*& _data;

  private:
    complexCharSeq_out();
    complexCharSeq_out& operator=(const complexCharSeq_var&);
  };

  struct complexUShort {
    typedef _CORBA_ConstrType_Fix_Var<complexUShort> _var_type;

    
    ::CORBA::UShort real;

    ::CORBA::UShort imag;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef complexUShort::_var_type complexUShort_var;

  typedef complexUShort& complexUShort_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_complexUShort;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_complexUShortSeq;

  class complexUShortSeq_var;

  class complexUShortSeq : public _CORBA_Unbounded_Sequence< complexUShort >  {
  public:
    typedef complexUShortSeq_var _var_type;
    inline complexUShortSeq() {}
    inline complexUShortSeq(const complexUShortSeq& _s)
      : _CORBA_Unbounded_Sequence< complexUShort > (_s) {}

    inline complexUShortSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< complexUShort > (_max) {}
    inline complexUShortSeq(_CORBA_ULong _max, _CORBA_ULong _len, complexUShort* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< complexUShort > (_max, _len, _val, _rel) {}

  

    inline complexUShortSeq& operator = (const complexUShortSeq& _s) {
      _CORBA_Unbounded_Sequence< complexUShort > ::operator=(_s);
      return *this;
    }
  };

  class complexUShortSeq_out;

  class complexUShortSeq_var {
  public:
    inline complexUShortSeq_var() : _pd_seq(0) {}
    inline complexUShortSeq_var(complexUShortSeq* _s) : _pd_seq(_s) {}
    inline complexUShortSeq_var(const complexUShortSeq_var& _s) {
      if (_s._pd_seq)  _pd_seq = new complexUShortSeq(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~complexUShortSeq_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline complexUShortSeq_var& operator = (complexUShortSeq* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline complexUShortSeq_var& operator = (const complexUShortSeq_var& _s) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new complexUShortSeq;
        *_pd_seq = *_s._pd_seq;
      } else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline complexUShort& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline complexUShortSeq* operator -> () { return _pd_seq; }
    inline const complexUShortSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator complexUShortSeq& () const { return *_pd_seq; }
#else
    inline operator const complexUShortSeq& () const { return *_pd_seq; }
    inline operator complexUShortSeq& () { return *_pd_seq; }
#endif
      
    inline const complexUShortSeq& in() const { return *_pd_seq; }
    inline complexUShortSeq&       inout()    { return *_pd_seq; }
    inline complexUShortSeq*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline complexUShortSeq* _retn() { complexUShortSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class complexUShortSeq_out;
    
  private:
    complexUShortSeq* _pd_seq;
  };

  class complexUShortSeq_out {
  public:
    inline complexUShortSeq_out(complexUShortSeq*& _s) : _data(_s) { _data = 0; }
    inline complexUShortSeq_out(complexUShortSeq_var& _s)
      : _data(_s._pd_seq) { _s = (complexUShortSeq*) 0; }
    inline complexUShortSeq_out(const complexUShortSeq_out& _s) : _data(_s._data) {}
    inline complexUShortSeq_out& operator = (const complexUShortSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline complexUShortSeq_out& operator = (complexUShortSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator complexUShortSeq*&()  { return _data; }
    inline complexUShortSeq*& ptr()       { return _data; }
    inline complexUShortSeq* operator->() { return _data; }

    inline complexUShort& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    complexUShortSeq*& _data;

  private:
    complexUShortSeq_out();
    complexUShortSeq_out& operator=(const complexUShortSeq_var&);
  };

  struct complexLong {
    typedef _CORBA_ConstrType_Fix_Var<complexLong> _var_type;

    
    ::CORBA::Long real;

    ::CORBA::Long imag;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef complexLong::_var_type complexLong_var;

  typedef complexLong& complexLong_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_complexLong;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_complexLongSeq;

  class complexLongSeq_var;

  class complexLongSeq : public _CORBA_Unbounded_Sequence< complexLong >  {
  public:
    typedef complexLongSeq_var _var_type;
    inline complexLongSeq() {}
    inline complexLongSeq(const complexLongSeq& _s)
      : _CORBA_Unbounded_Sequence< complexLong > (_s) {}

    inline complexLongSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< complexLong > (_max) {}
    inline complexLongSeq(_CORBA_ULong _max, _CORBA_ULong _len, complexLong* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< complexLong > (_max, _len, _val, _rel) {}

  

    inline complexLongSeq& operator = (const complexLongSeq& _s) {
      _CORBA_Unbounded_Sequence< complexLong > ::operator=(_s);
      return *this;
    }
  };

  class complexLongSeq_out;

  class complexLongSeq_var {
  public:
    inline complexLongSeq_var() : _pd_seq(0) {}
    inline complexLongSeq_var(complexLongSeq* _s) : _pd_seq(_s) {}
    inline complexLongSeq_var(const complexLongSeq_var& _s) {
      if (_s._pd_seq)  _pd_seq = new complexLongSeq(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~complexLongSeq_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline complexLongSeq_var& operator = (complexLongSeq* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline complexLongSeq_var& operator = (const complexLongSeq_var& _s) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new complexLongSeq;
        *_pd_seq = *_s._pd_seq;
      } else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline complexLong& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline complexLongSeq* operator -> () { return _pd_seq; }
    inline const complexLongSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator complexLongSeq& () const { return *_pd_seq; }
#else
    inline operator const complexLongSeq& () const { return *_pd_seq; }
    inline operator complexLongSeq& () { return *_pd_seq; }
#endif
      
    inline const complexLongSeq& in() const { return *_pd_seq; }
    inline complexLongSeq&       inout()    { return *_pd_seq; }
    inline complexLongSeq*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline complexLongSeq* _retn() { complexLongSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class complexLongSeq_out;
    
  private:
    complexLongSeq* _pd_seq;
  };

  class complexLongSeq_out {
  public:
    inline complexLongSeq_out(complexLongSeq*& _s) : _data(_s) { _data = 0; }
    inline complexLongSeq_out(complexLongSeq_var& _s)
      : _data(_s._pd_seq) { _s = (complexLongSeq*) 0; }
    inline complexLongSeq_out(const complexLongSeq_out& _s) : _data(_s._data) {}
    inline complexLongSeq_out& operator = (const complexLongSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline complexLongSeq_out& operator = (complexLongSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator complexLongSeq*&()  { return _data; }
    inline complexLongSeq*& ptr()       { return _data; }
    inline complexLongSeq* operator->() { return _data; }

    inline complexLong& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    complexLongSeq*& _data;

  private:
    complexLongSeq_out();
    complexLongSeq_out& operator=(const complexLongSeq_var&);
  };

  struct complexLongLong {
    typedef _CORBA_ConstrType_Fix_Var<complexLongLong> _var_type;

    
    ::CORBA::LongLong real;

    ::CORBA::LongLong imag;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef complexLongLong::_var_type complexLongLong_var;

  typedef complexLongLong& complexLongLong_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_complexLongLong;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_complexLongLongSeq;

  class complexLongLongSeq_var;

  class complexLongLongSeq : public _CORBA_Unbounded_Sequence< complexLongLong >  {
  public:
    typedef complexLongLongSeq_var _var_type;
    inline complexLongLongSeq() {}
    inline complexLongLongSeq(const complexLongLongSeq& _s)
      : _CORBA_Unbounded_Sequence< complexLongLong > (_s) {}

    inline complexLongLongSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< complexLongLong > (_max) {}
    inline complexLongLongSeq(_CORBA_ULong _max, _CORBA_ULong _len, complexLongLong* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< complexLongLong > (_max, _len, _val, _rel) {}

  

    inline complexLongLongSeq& operator = (const complexLongLongSeq& _s) {
      _CORBA_Unbounded_Sequence< complexLongLong > ::operator=(_s);
      return *this;
    }
  };

  class complexLongLongSeq_out;

  class complexLongLongSeq_var {
  public:
    inline complexLongLongSeq_var() : _pd_seq(0) {}
    inline complexLongLongSeq_var(complexLongLongSeq* _s) : _pd_seq(_s) {}
    inline complexLongLongSeq_var(const complexLongLongSeq_var& _s) {
      if (_s._pd_seq)  _pd_seq = new complexLongLongSeq(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~complexLongLongSeq_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline complexLongLongSeq_var& operator = (complexLongLongSeq* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline complexLongLongSeq_var& operator = (const complexLongLongSeq_var& _s) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new complexLongLongSeq;
        *_pd_seq = *_s._pd_seq;
      } else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline complexLongLong& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline complexLongLongSeq* operator -> () { return _pd_seq; }
    inline const complexLongLongSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator complexLongLongSeq& () const { return *_pd_seq; }
#else
    inline operator const complexLongLongSeq& () const { return *_pd_seq; }
    inline operator complexLongLongSeq& () { return *_pd_seq; }
#endif
      
    inline const complexLongLongSeq& in() const { return *_pd_seq; }
    inline complexLongLongSeq&       inout()    { return *_pd_seq; }
    inline complexLongLongSeq*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline complexLongLongSeq* _retn() { complexLongLongSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class complexLongLongSeq_out;
    
  private:
    complexLongLongSeq* _pd_seq;
  };

  class complexLongLongSeq_out {
  public:
    inline complexLongLongSeq_out(complexLongLongSeq*& _s) : _data(_s) { _data = 0; }
    inline complexLongLongSeq_out(complexLongLongSeq_var& _s)
      : _data(_s._pd_seq) { _s = (complexLongLongSeq*) 0; }
    inline complexLongLongSeq_out(const complexLongLongSeq_out& _s) : _data(_s._data) {}
    inline complexLongLongSeq_out& operator = (const complexLongLongSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline complexLongLongSeq_out& operator = (complexLongLongSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator complexLongLongSeq*&()  { return _data; }
    inline complexLongLongSeq*& ptr()       { return _data; }
    inline complexLongLongSeq* operator->() { return _data; }

    inline complexLongLong& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    complexLongLongSeq*& _data;

  private:
    complexLongLongSeq_out();
    complexLongLongSeq_out& operator=(const complexLongLongSeq_var&);
  };

  struct complexULongLong {
    typedef _CORBA_ConstrType_Fix_Var<complexULongLong> _var_type;

    
    ::CORBA::ULongLong real;

    ::CORBA::ULongLong imag;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef complexULongLong::_var_type complexULongLong_var;

  typedef complexULongLong& complexULongLong_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_complexULongLong;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_complexULongLongSeq;

  class complexULongLongSeq_var;

  class complexULongLongSeq : public _CORBA_Unbounded_Sequence< complexULongLong >  {
  public:
    typedef complexULongLongSeq_var _var_type;
    inline complexULongLongSeq() {}
    inline complexULongLongSeq(const complexULongLongSeq& _s)
      : _CORBA_Unbounded_Sequence< complexULongLong > (_s) {}

    inline complexULongLongSeq(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< complexULongLong > (_max) {}
    inline complexULongLongSeq(_CORBA_ULong _max, _CORBA_ULong _len, complexULongLong* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< complexULongLong > (_max, _len, _val, _rel) {}

  

    inline complexULongLongSeq& operator = (const complexULongLongSeq& _s) {
      _CORBA_Unbounded_Sequence< complexULongLong > ::operator=(_s);
      return *this;
    }
  };

  class complexULongLongSeq_out;

  class complexULongLongSeq_var {
  public:
    inline complexULongLongSeq_var() : _pd_seq(0) {}
    inline complexULongLongSeq_var(complexULongLongSeq* _s) : _pd_seq(_s) {}
    inline complexULongLongSeq_var(const complexULongLongSeq_var& _s) {
      if (_s._pd_seq)  _pd_seq = new complexULongLongSeq(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~complexULongLongSeq_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline complexULongLongSeq_var& operator = (complexULongLongSeq* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline complexULongLongSeq_var& operator = (const complexULongLongSeq_var& _s) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new complexULongLongSeq;
        *_pd_seq = *_s._pd_seq;
      } else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline complexULongLong& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline complexULongLongSeq* operator -> () { return _pd_seq; }
    inline const complexULongLongSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator complexULongLongSeq& () const { return *_pd_seq; }
#else
    inline operator const complexULongLongSeq& () const { return *_pd_seq; }
    inline operator complexULongLongSeq& () { return *_pd_seq; }
#endif
      
    inline const complexULongLongSeq& in() const { return *_pd_seq; }
    inline complexULongLongSeq&       inout()    { return *_pd_seq; }
    inline complexULongLongSeq*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline complexULongLongSeq* _retn() { complexULongLongSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class complexULongLongSeq_out;
    
  private:
    complexULongLongSeq* _pd_seq;
  };

  class complexULongLongSeq_out {
  public:
    inline complexULongLongSeq_out(complexULongLongSeq*& _s) : _data(_s) { _data = 0; }
    inline complexULongLongSeq_out(complexULongLongSeq_var& _s)
      : _data(_s._pd_seq) { _s = (complexULongLongSeq*) 0; }
    inline complexULongLongSeq_out(const complexULongLongSeq_out& _s) : _data(_s._data) {}
    inline complexULongLongSeq_out& operator = (const complexULongLongSeq_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline complexULongLongSeq_out& operator = (complexULongLongSeq* _s) {
      _data = _s;
      return *this;
    }
    inline operator complexULongLongSeq*&()  { return _data; }
    inline complexULongLongSeq*& ptr()       { return _data; }
    inline complexULongLongSeq* operator->() { return _data; }

    inline complexULongLong& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    complexULongLongSeq*& _data;

  private:
    complexULongLongSeq_out();
    complexULongLongSeq_out& operator=(const complexULongLongSeq_var&);
  };

_CORBA_MODULE_END



_CORBA_MODULE POA_PortTypes
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE POA_CF
_CORBA_MODULE_BEG

_CORBA_MODULE_END



_CORBA_MODULE OBV_PortTypes
_CORBA_MODULE_BEG

_CORBA_MODULE_END

_CORBA_MODULE OBV_CF
_CORBA_MODULE_BEG

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr

void operator<<=(::CORBA::Any& _a, const PortTypes::DoubleSequence& _s);
void operator<<=(::CORBA::Any& _a, PortTypes::DoubleSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, PortTypes::DoubleSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const PortTypes::DoubleSequence*& _sp);

void operator<<=(::CORBA::Any& _a, const PortTypes::FloatSequence& _s);
void operator<<=(::CORBA::Any& _a, PortTypes::FloatSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, PortTypes::FloatSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const PortTypes::FloatSequence*& _sp);

void operator<<=(::CORBA::Any& _a, const PortTypes::LongLongSequence& _s);
void operator<<=(::CORBA::Any& _a, PortTypes::LongLongSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, PortTypes::LongLongSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const PortTypes::LongLongSequence*& _sp);

void operator<<=(::CORBA::Any& _a, const PortTypes::UlongSequence& _s);
void operator<<=(::CORBA::Any& _a, PortTypes::UlongSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, PortTypes::UlongSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const PortTypes::UlongSequence*& _sp);

void operator<<=(::CORBA::Any& _a, const PortTypes::UlongLongSequence& _s);
void operator<<=(::CORBA::Any& _a, PortTypes::UlongLongSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, PortTypes::UlongLongSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const PortTypes::UlongLongSequence*& _sp);

void operator<<=(::CORBA::Any& _a, const PortTypes::ShortSequence& _s);
void operator<<=(::CORBA::Any& _a, PortTypes::ShortSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, PortTypes::ShortSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const PortTypes::ShortSequence*& _sp);

void operator<<=(::CORBA::Any& _a, const PortTypes::UshortSequence& _s);
void operator<<=(::CORBA::Any& _a, PortTypes::UshortSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, PortTypes::UshortSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const PortTypes::UshortSequence*& _sp);

void operator<<=(::CORBA::Any& _a, const PortTypes::CharSequence& _s);
void operator<<=(::CORBA::Any& _a, PortTypes::CharSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, PortTypes::CharSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const PortTypes::CharSequence*& _sp);

void operator<<=(::CORBA::Any& _a, const PortTypes::LongSequence& _s);
void operator<<=(::CORBA::Any& _a, PortTypes::LongSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, PortTypes::LongSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const PortTypes::LongSequence*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CF::complexDouble& _s);
extern void operator<<=(::CORBA::Any& _a, CF::complexDouble* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::complexDouble*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::complexDouble*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::complexDoubleSeq& _s);
void operator<<=(::CORBA::Any& _a, CF::complexDoubleSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::complexDoubleSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::complexDoubleSeq*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CF::complexFloat& _s);
extern void operator<<=(::CORBA::Any& _a, CF::complexFloat* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::complexFloat*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::complexFloat*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::complexFloatSeq& _s);
void operator<<=(::CORBA::Any& _a, CF::complexFloatSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::complexFloatSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::complexFloatSeq*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CF::complexBoolean& _s);
extern void operator<<=(::CORBA::Any& _a, CF::complexBoolean* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::complexBoolean*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::complexBoolean*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::complexBooleanSeq& _s);
void operator<<=(::CORBA::Any& _a, CF::complexBooleanSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::complexBooleanSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::complexBooleanSeq*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CF::complexULong& _s);
extern void operator<<=(::CORBA::Any& _a, CF::complexULong* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::complexULong*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::complexULong*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::complexULongSeq& _s);
void operator<<=(::CORBA::Any& _a, CF::complexULongSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::complexULongSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::complexULongSeq*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CF::complexShort& _s);
extern void operator<<=(::CORBA::Any& _a, CF::complexShort* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::complexShort*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::complexShort*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::complexShortSeq& _s);
void operator<<=(::CORBA::Any& _a, CF::complexShortSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::complexShortSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::complexShortSeq*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CF::complexOctet& _s);
extern void operator<<=(::CORBA::Any& _a, CF::complexOctet* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::complexOctet*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::complexOctet*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::complexOctetSeq& _s);
void operator<<=(::CORBA::Any& _a, CF::complexOctetSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::complexOctetSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::complexOctetSeq*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CF::complexChar& _s);
extern void operator<<=(::CORBA::Any& _a, CF::complexChar* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::complexChar*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::complexChar*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::complexCharSeq& _s);
void operator<<=(::CORBA::Any& _a, CF::complexCharSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::complexCharSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::complexCharSeq*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CF::complexUShort& _s);
extern void operator<<=(::CORBA::Any& _a, CF::complexUShort* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::complexUShort*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::complexUShort*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::complexUShortSeq& _s);
void operator<<=(::CORBA::Any& _a, CF::complexUShortSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::complexUShortSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::complexUShortSeq*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CF::complexLong& _s);
extern void operator<<=(::CORBA::Any& _a, CF::complexLong* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::complexLong*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::complexLong*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::complexLongSeq& _s);
void operator<<=(::CORBA::Any& _a, CF::complexLongSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::complexLongSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::complexLongSeq*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CF::complexLongLong& _s);
extern void operator<<=(::CORBA::Any& _a, CF::complexLongLong* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::complexLongLong*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::complexLongLong*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::complexLongLongSeq& _s);
void operator<<=(::CORBA::Any& _a, CF::complexLongLongSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::complexLongLongSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::complexLongLongSeq*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CF::complexULongLong& _s);
extern void operator<<=(::CORBA::Any& _a, CF::complexULongLong* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::complexULongLong*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::complexULongLong*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::complexULongLongSeq& _s);
void operator<<=(::CORBA::Any& _a, CF::complexULongLongSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::complexULongLongSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::complexULongLongSeq*& _sp);





#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_AdditionalTypes
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_AdditionalTypes
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_AdditionalTypes
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_AdditionalTypes
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_AdditionalTypes
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_AdditionalTypes
#endif

#endif  // __AdditionalTypes_hh__

