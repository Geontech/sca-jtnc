// This file is generated by omniidl (C++ backend)- omniORB_4_2. Do not edit.
#ifndef __bulkioDataTypes_hh__
#define __bulkioDataTypes_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_bulkioDataTypes
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_bulkioDataTypes
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_bulkioDataTypes
#endif



#ifndef __CFProperties_hh_EXTERNAL_GUARD__
#define __CFProperties_hh_EXTERNAL_GUARD__
#include <sca/CF/CFProperties.h>
#endif



#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif



_CORBA_MODULE BULKIO

_CORBA_MODULE_BEG

  _CORBA_MODULE_VARINT const ::CORBA::Short TCM_OFF _init_in_decl_( = 0 );

  _CORBA_MODULE_VARINT const ::CORBA::Short TCM_CPU _init_in_decl_( = 1 );

  _CORBA_MODULE_VARINT const ::CORBA::Short TCM_ZTC _init_in_decl_( = 2 );

  _CORBA_MODULE_VARINT const ::CORBA::Short TCM_SDN _init_in_decl_( = 3 );

  _CORBA_MODULE_VARINT const ::CORBA::Short TCM_SMS _init_in_decl_( = 4 );

  _CORBA_MODULE_VARINT const ::CORBA::Short TCM_DTL _init_in_decl_( = 5 );

  _CORBA_MODULE_VARINT const ::CORBA::Short TCM_IRB _init_in_decl_( = 6 );

  _CORBA_MODULE_VARINT const ::CORBA::Short TCM_SDDS _init_in_decl_( = 7 );

  _CORBA_MODULE_VARINT const ::CORBA::Short TCS_INVALID _init_in_decl_( = 0 );

  _CORBA_MODULE_VARINT const ::CORBA::Short TCS_VALID _init_in_decl_( = 1 );

  _CORBA_MODULE_VARINT const ::CORBA::Short UNITS_NONE _init_in_decl_( = 0 );

  _CORBA_MODULE_VARINT const ::CORBA::Short UNITS_TIME _init_in_decl_( = 1 );

  _CORBA_MODULE_VARINT const ::CORBA::Short UNITS_DELAY _init_in_decl_( = 2 );

  _CORBA_MODULE_VARINT const ::CORBA::Short UNITS_FREQUENCY _init_in_decl_( = 3 );

  _CORBA_MODULE_VARINT const ::CORBA::Short UNITS_TIMECODE _init_in_decl_( = 4 );

  _CORBA_MODULE_VARINT const ::CORBA::Short UNITS_DISTANCE _init_in_decl_( = 5 );

  _CORBA_MODULE_VARINT const ::CORBA::Short UNITS_VELOCITY _init_in_decl_( = 6 );

  _CORBA_MODULE_VARINT const ::CORBA::Short UNITS_ACCELERATION _init_in_decl_( = 7 );

  _CORBA_MODULE_VARINT const ::CORBA::Short UNITS_JERK _init_in_decl_( = 8 );

  _CORBA_MODULE_VARINT const ::CORBA::Short UNITS_DOPPLER _init_in_decl_( = 9 );

  _CORBA_MODULE_VARINT const ::CORBA::Short UNITS_DOPPLERRATE _init_in_decl_( = 10 );

  _CORBA_MODULE_VARINT const ::CORBA::Short UNITS_ENERGY _init_in_decl_( = 11 );

  _CORBA_MODULE_VARINT const ::CORBA::Short UNITS_POWER _init_in_decl_( = 12 );

  _CORBA_MODULE_VARINT const ::CORBA::Short UNITS_MASS _init_in_decl_( = 13 );

  struct PrecisionUTCTime {
    typedef _CORBA_ConstrType_Fix_Var<PrecisionUTCTime> _var_type;

    
    ::CORBA::Short tcmode;

    ::CORBA::Short tcstatus;

    ::CORBA::Double toff;

    ::CORBA::Double twsec;

    ::CORBA::Double tfsec;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef PrecisionUTCTime::_var_type PrecisionUTCTime_var;

  typedef PrecisionUTCTime& PrecisionUTCTime_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PrecisionUTCTime;

  struct StreamSRI {
    typedef _CORBA_ConstrType_Variable_Var<StreamSRI> _var_type;

    
    ::CORBA::Long hversion;

    ::CORBA::Double xstart;

    ::CORBA::Double xdelta;

    ::CORBA::Short xunits;

    ::CORBA::Long subsize;

    ::CORBA::Double ystart;

    ::CORBA::Double ydelta;

    ::CORBA::Short yunits;

    ::CORBA::Short mode;

    ::CORBA::String_member streamID;

    ::CORBA::Boolean blocking;

    typedef _CORBA_Unbounded_Sequence< CF::DataType >  _keywords_seq;
    _keywords_seq keywords;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef StreamSRI::_var_type StreamSRI_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< StreamSRI,StreamSRI_var > StreamSRI_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_StreamSRI;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_StringSequence;

  class StringSequence_var;

  class StringSequence : public _CORBA_Unbounded_Sequence_String {
  public:
    typedef StringSequence_var _var_type;
    inline StringSequence() {}
    inline StringSequence(const StringSequence& _s)
      : _CORBA_Unbounded_Sequence_String(_s) {}

    inline StringSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_String(_max) {}
    inline StringSequence(_CORBA_ULong _max, _CORBA_ULong _len, char** _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_String(_max, _len, _val, _rel) {}

  

    inline StringSequence& operator = (const StringSequence& _s) {
      _CORBA_Unbounded_Sequence_String::operator=(_s);
      return *this;
    }
  };

  class StringSequence_out;

  class StringSequence_var {
  public:
    inline StringSequence_var() : _pd_seq(0) {}
    inline StringSequence_var(StringSequence* _s) : _pd_seq(_s) {}
    inline StringSequence_var(const StringSequence_var& _s) {
      if (_s._pd_seq)  _pd_seq = new StringSequence(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~StringSequence_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline StringSequence_var& operator = (StringSequence* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline StringSequence_var& operator = (const StringSequence_var& _s) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new StringSequence;
        *_pd_seq = *_s._pd_seq;
      } else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline _CORBA_String_element operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline StringSequence* operator -> () { return _pd_seq; }
    inline const StringSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator StringSequence& () const { return *_pd_seq; }
#else
    inline operator const StringSequence& () const { return *_pd_seq; }
    inline operator StringSequence& () { return *_pd_seq; }
#endif
      
    inline const StringSequence& in() const { return *_pd_seq; }
    inline StringSequence&       inout()    { return *_pd_seq; }
    inline StringSequence*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline StringSequence* _retn() { StringSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class StringSequence_out;
    
  private:
    StringSequence* _pd_seq;
  };

  class StringSequence_out {
  public:
    inline StringSequence_out(StringSequence*& _s) : _data(_s) { _data = 0; }
    inline StringSequence_out(StringSequence_var& _s)
      : _data(_s._pd_seq) { _s = (StringSequence*) 0; }
    inline StringSequence_out(const StringSequence_out& _s) : _data(_s._data) {}
    inline StringSequence_out& operator = (const StringSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline StringSequence_out& operator = (StringSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator StringSequence*&()  { return _data; }
    inline StringSequence*& ptr()       { return _data; }
    inline StringSequence* operator->() { return _data; }

    inline _CORBA_String_element operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    StringSequence*& _data;

  private:
    StringSequence_out();
    StringSequence_out& operator=(const StringSequence_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_StreamSRISequence;

  class StreamSRISequence_var;

  class StreamSRISequence : public _CORBA_Unbounded_Sequence< StreamSRI >  {
  public:
    typedef StreamSRISequence_var _var_type;
    inline StreamSRISequence() {}
    inline StreamSRISequence(const StreamSRISequence& _s)
      : _CORBA_Unbounded_Sequence< StreamSRI > (_s) {}

    inline StreamSRISequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< StreamSRI > (_max) {}
    inline StreamSRISequence(_CORBA_ULong _max, _CORBA_ULong _len, StreamSRI* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< StreamSRI > (_max, _len, _val, _rel) {}

  

    inline StreamSRISequence& operator = (const StreamSRISequence& _s) {
      _CORBA_Unbounded_Sequence< StreamSRI > ::operator=(_s);
      return *this;
    }
  };

  class StreamSRISequence_out;

  class StreamSRISequence_var {
  public:
    inline StreamSRISequence_var() : _pd_seq(0) {}
    inline StreamSRISequence_var(StreamSRISequence* _s) : _pd_seq(_s) {}
    inline StreamSRISequence_var(const StreamSRISequence_var& _s) {
      if (_s._pd_seq)  _pd_seq = new StreamSRISequence(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~StreamSRISequence_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline StreamSRISequence_var& operator = (StreamSRISequence* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline StreamSRISequence_var& operator = (const StreamSRISequence_var& _s) {
      if (_s._pd_seq) {
        if (!_pd_seq)  _pd_seq = new StreamSRISequence;
        *_pd_seq = *_s._pd_seq;
      } else if (_pd_seq) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline StreamSRI& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline StreamSRISequence* operator -> () { return _pd_seq; }
    inline const StreamSRISequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator StreamSRISequence& () const { return *_pd_seq; }
#else
    inline operator const StreamSRISequence& () const { return *_pd_seq; }
    inline operator StreamSRISequence& () { return *_pd_seq; }
#endif
      
    inline const StreamSRISequence& in() const { return *_pd_seq; }
    inline StreamSRISequence&       inout()    { return *_pd_seq; }
    inline StreamSRISequence*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline StreamSRISequence* _retn() { StreamSRISequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class StreamSRISequence_out;
    
  private:
    StreamSRISequence* _pd_seq;
  };

  class StreamSRISequence_out {
  public:
    inline StreamSRISequence_out(StreamSRISequence*& _s) : _data(_s) { _data = 0; }
    inline StreamSRISequence_out(StreamSRISequence_var& _s)
      : _data(_s._pd_seq) { _s = (StreamSRISequence*) 0; }
    inline StreamSRISequence_out(const StreamSRISequence_out& _s) : _data(_s._data) {}
    inline StreamSRISequence_out& operator = (const StreamSRISequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline StreamSRISequence_out& operator = (StreamSRISequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator StreamSRISequence*&()  { return _data; }
    inline StreamSRISequence*& ptr()       { return _data; }
    inline StreamSRISequence* operator->() { return _data; }

    inline StreamSRI& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    StreamSRISequence*& _data;

  private:
    StreamSRISequence_out();
    StreamSRISequence_out& operator=(const StreamSRISequence_var&);
  };

_CORBA_MODULE_END



_CORBA_MODULE POA_BULKIO
_CORBA_MODULE_BEG

_CORBA_MODULE_END



_CORBA_MODULE OBV_BULKIO
_CORBA_MODULE_BEG

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr

extern void operator<<=(::CORBA::Any& _a, const BULKIO::PrecisionUTCTime& _s);
extern void operator<<=(::CORBA::Any& _a, BULKIO::PrecisionUTCTime* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, BULKIO::PrecisionUTCTime*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const BULKIO::PrecisionUTCTime*& _sp);

extern void operator<<=(::CORBA::Any& _a, const BULKIO::StreamSRI& _s);
extern void operator<<=(::CORBA::Any& _a, BULKIO::StreamSRI* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, BULKIO::StreamSRI*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const BULKIO::StreamSRI*& _sp);

void operator<<=(::CORBA::Any& _a, const BULKIO::StringSequence& _s);
void operator<<=(::CORBA::Any& _a, BULKIO::StringSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, BULKIO::StringSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const BULKIO::StringSequence*& _sp);

void operator<<=(::CORBA::Any& _a, const BULKIO::StreamSRISequence& _s);
void operator<<=(::CORBA::Any& _a, BULKIO::StreamSRISequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, BULKIO::StreamSRISequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const BULKIO::StreamSRISequence*& _sp);





#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_bulkioDataTypes
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_bulkioDataTypes
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_bulkioDataTypes
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_bulkioDataTypes
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_bulkioDataTypes
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_bulkioDataTypes
#endif

#endif  // __bulkioDataTypes_hh__

